Autogenerated from [https://www.improwis.com/projects/sw_chip_SHT30/](https://www.improwis.com/projects/sw_chip_SHT30/)






SHT3x-read







SHT3x-read
==========



---

[Why](#Why "#Why")  
[How](#How "How")  
      [chip](#chip "How.chip")  
      [code](#code "How.code")  
[Usage](#Usage "Usage")  
      [options](#options "Usage.options")  
      [output](#output "Usage.output")  
            [examples](#examples "Usage.output.examples")  
[Compiling](#Compiling "Compiling")  
[Files](#Files "Files")  
[TODO](#TODO "TODO")  


---

Why
---



The [SHT30](https://www.improwis.com/datasheets/SHT30, SHT31 - temperature and humidity sensor.pdf "local file - datasheet") is a fairly inexpensive [I2C](https://en.wikipedia.org/wiki/I2C "Wikipedia link: I2C") temperature and [relative humidity](https://en.wikipedia.org/wiki/relative_humidity "Wikipedia link: relative humidity") sensor.




Python library is available.




For reading from shell scripts, especially on underpowered boards like Raspberry Pi 1, python is less suitable due to the
overheads at process startup. Insane amount of files has to be read and interpreted. A frequently executed task will
bring a significant load on the machine.





---

How
---



A simple C code was derived from the [sw\_chip\_PCF8591](https://www.improwis.com/projects/sw_chip_PCF8591 "local project") one.




As the sensor doesn't do conventional registers, and only bare reads and writes are used (so eg. i2cdump will show just
all zeroes and confuse the register settings), the barest of interfacing will do. File and IOCTL access to /dev/i2c-something
was therefore chosen.



### chip



The chip operates in a simple way. Send a two-byte command. Optionally wait. Read raw bytes from the chip, calculate output values.



### code



The code first opens the I2C device (or fails when device doesn't exist or is inaccessible).
IOCTL I2C\_SLAVE is executed on the resulting file handle, with the chip's address as parameter.




The command word is sent (code fails here if the chip is not on the given address).




Then several bytes are read. For the temp/humi values, it is six bytes, with two bytes for temperature (MSB+LSB) and third for CRC,
then two bytes for humidity (MSB+LSB) and third for CRC. The CRC is at this moment ignored.





---

Usage
-----


### options



If executed without options, it queries first SHT30 sensor on the /dev/i2c-1 bus. This is a default
configuration on raspberry pi boards.




```
SHT3x sensor read
Usage: sht30 [-h<0|1>] [-i] [-r<h|t|ht>] [-j] [-s] [-sc] [-a0] [-a1] [-d <dev>] [-v] 
measure:
  -i        integer mode (no float)
  -rh       output single-line humidity
  -rt       output single-line temperature
  -rht      output single-line humidity and temperature
  -j        JSON format
  -nr       do not read humidity/temp
chip setting:
  -h1       on-chip heater enable
  -h0       on-chip heater disable
  -s        read status word
  -sc       clear status word
  -R        reset chip
I2C:
  -a0       address ADDR=L (0x44, default)
  -a1       address ADDR=H (0x45)
  -d <dev>  specify I2C device, default /dev/i2c-1
general:
  -v        verbose mode
  -h,--help this help


```
* measure
+ -i - integer mode, no float, for shell scripts that don't like floats
+ -rh - read and output single number, humidity
+ -rt - read and output single number, temperature
+ -rht - read and output two space-separated numbers, humidity then temperature
+ -j - output humidity-temperature pair in JSON format
+ -nr - no read, skip measurement and output of humi/temp

* chip setting
+ -h1 - enable on-chip heater
+ -h0 - disable on-chip heater
+ -s - read and interpret status word (16 bits)
+ -sc - clear flags in status word
+ -R - soft-reset chip
+ - -

* I2C
+ -a0 - select the first chip on the bus, default address 0x44
+ -a1 - select the second chip on the bus, default address 0x45
+ -d /dev/i2c-something - specify the I2C device to access

* general
+ -v - verbose mode, report every read and device open; suitable for debugging
+ -h - help
+ --help - help; seriously, why every software has one or the other and never both?!?

### output



If all is okay, result code is 0. Otherwise, if something crashes, result is 1.




If not verbose or help, two lines with human-readable data go to stdout; or only one or both values.



#### examples


./sht30Humidity : 39.40 %Temperature: 23.90 'C
 
./sht30 -rt -i24 
./sht30 -j{"humi":39.43,"temp":23.90} 
./sht30 -nr -sStatus: 0000 pending alert : false heater enabled : false humi alert : false temp alert : false read periodic : false reset detect : false command fail : false checksum fail : false




---

Compiling
---------



The code doesn't need any special compilation. A simple call will do:
* cc -o sht30 sht30.c

or, for statically linked version,
* cc -o sht30 -static sht30.c





---

Files
-----


* [sht30.c](sht30.c "local file") - source code
* [Makefile](Makefile "local file") - for easier compilation
* [sht30-raspi](sht30-raspi "local file") - binary for raspberry pi
* [sht30-raspi-static](sht30-raspi-static "local file") - binary for raspberry pi, statically linked



---

TODO
----


* enable periodic readouts






